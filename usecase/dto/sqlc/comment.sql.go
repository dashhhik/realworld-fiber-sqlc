// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: comment.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createComment = `-- name: CreateComment :one

INSERT INTO comments (article_id, user_id, body, created_at, updated_at)
VALUES (
           (SELECT id FROM articles WHERE slug = $1),
           $2,
           $3,
           TO_TIMESTAMP(CURRENT_TIMESTAMP, 'YYYY-MM-DD"T"HH24:MI:SS.MS"Z"'),
           TO_TIMESTAMP(CURRENT_TIMESTAMP, 'YYYY-MM-DD"T"HH24:MI:SS.MS"Z"')
       )
RETURNING id, created_at, updated_at, body
`

type CreateCommentParams struct {
	Slug   string      `json:"slug"`
	UserID pgtype.Int8 `json:"user_id"`
	Body   string      `json:"body"`
}

type CreateCommentRow struct {
	ID        int32            `json:"id"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
	Body      string           `json:"body"`
}

// comment.sql
func (q *Queries) CreateComment(ctx context.Context, arg CreateCommentParams) (CreateCommentRow, error) {
	row := q.db.QueryRow(ctx, createComment, arg.Slug, arg.UserID, arg.Body)
	var i CreateCommentRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Body,
	)
	return i, err
}

const deleteComment = `-- name: DeleteComment :exec
DELETE FROM comments
WHERE id = $1 AND user_id = $2
`

type DeleteCommentParams struct {
	ID     int32       `json:"id"`
	UserID pgtype.Int8 `json:"user_id"`
}

func (q *Queries) DeleteComment(ctx context.Context, arg DeleteCommentParams) error {
	_, err := q.db.Exec(ctx, deleteComment, arg.ID, arg.UserID)
	return err
}

const getCommentsByArticleSlug = `-- name: GetCommentsByArticleSlug :many
SELECT
    c.id,
    TO_CHAR(c.created_at, 'YYYY-MM-DD"T"HH24:MI:SS.MS"Z"') AS createdAt,
    TO_CHAR(c.updated_at, 'YYYY-MM-DD"T"HH24:MI:SS.MS"Z"') AS updatedAt,
    c.body,
    u.username,
    u.bio,
    u.image,
    FALSE AS following
FROM comments c
         JOIN users u ON c.user_id = u.id
WHERE c.article_id = (SELECT id FROM articles WHERE slug = $1)
`

type GetCommentsByArticleSlugRow struct {
	ID        int32       `json:"id"`
	Createdat string      `json:"createdat"`
	Updatedat string      `json:"updatedat"`
	Body      string      `json:"body"`
	Username  string      `json:"username"`
	Bio       pgtype.Text `json:"bio"`
	Image     pgtype.Text `json:"image"`
	Following bool        `json:"following"`
}

func (q *Queries) GetCommentsByArticleSlug(ctx context.Context, slug string) ([]GetCommentsByArticleSlugRow, error) {
	rows, err := q.db.Query(ctx, getCommentsByArticleSlug, slug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCommentsByArticleSlugRow{}
	for rows.Next() {
		var i GetCommentsByArticleSlugRow
		if err := rows.Scan(
			&i.ID,
			&i.Createdat,
			&i.Updatedat,
			&i.Body,
			&i.Username,
			&i.Bio,
			&i.Image,
			&i.Following,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSingleComment = `-- name: GetSingleComment :one
SELECT
    c.id,
    c.created_at AS createdAt,
    c.updated_at AS updatedAt,
    c.body,
    u.username,
    u.bio,
    u.image,
    FALSE AS following  -- заменить на реальную логику определения, следует ли автору
FROM comments c
         JOIN users u ON c.user_id = u.id
WHERE c.id = (SELECT MAX(id) FROM comments)
`

type GetSingleCommentRow struct {
	ID        int32            `json:"id"`
	Createdat pgtype.Timestamp `json:"createdat"`
	Updatedat pgtype.Timestamp `json:"updatedat"`
	Body      string           `json:"body"`
	Username  string           `json:"username"`
	Bio       pgtype.Text      `json:"bio"`
	Image     pgtype.Text      `json:"image"`
	Following bool             `json:"following"`
}

func (q *Queries) GetSingleComment(ctx context.Context) (GetSingleCommentRow, error) {
	row := q.db.QueryRow(ctx, getSingleComment)
	var i GetSingleCommentRow
	err := row.Scan(
		&i.ID,
		&i.Createdat,
		&i.Updatedat,
		&i.Body,
		&i.Username,
		&i.Bio,
		&i.Image,
		&i.Following,
	)
	return i, err
}
