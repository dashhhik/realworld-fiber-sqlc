// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: article.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createArticle = `-- name: CreateArticle :one
INSERT INTO articles (slug, title, description, body, author_id)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, slug, title, description, body, created_at, updated_at, favorites_count, author_id
`

type CreateArticleParams struct {
	Slug        string
	Title       string
	Description string
	Body        string
	AuthorID    pgtype.Int8
}

func (q *Queries) CreateArticle(ctx context.Context, arg CreateArticleParams) (Article, error) {
	row := q.db.QueryRow(ctx, createArticle,
		arg.Slug,
		arg.Title,
		arg.Description,
		arg.Body,
		arg.AuthorID,
	)
	var i Article
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Title,
		&i.Description,
		&i.Body,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FavoritesCount,
		&i.AuthorID,
	)
	return i, err
}

const deleteArticle = `-- name: DeleteArticle :one
DELETE FROM articles
WHERE slug = $1 and author_id = $2
RETURNING id, slug, title, description, body, created_at, updated_at, favorites_count, author_id
`

type DeleteArticleParams struct {
	Slug     string
	AuthorID pgtype.Int8
}

func (q *Queries) DeleteArticle(ctx context.Context, arg DeleteArticleParams) (Article, error) {
	row := q.db.QueryRow(ctx, deleteArticle, arg.Slug, arg.AuthorID)
	var i Article
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Title,
		&i.Description,
		&i.Body,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FavoritesCount,
		&i.AuthorID,
	)
	return i, err
}

const favoriteArticle = `-- name: FavoriteArticle :one
WITH article_id_cte AS (
    SELECT a.id
    FROM articles a
    WHERE a.slug = $1
), insert_favorite AS (
    INSERT INTO favorites (user_id, article_id)
        SELECT $2, a.id
        FROM article_id_cte a
        RETURNING article_id
)
UPDATE articles
SET favorites_count = favorites_count + 1
WHERE id = (SELECT article_id FROM insert_favorite)
RETURNING id, slug, title, description, body, created_at, updated_at, favorites_count, author_id
`

type FavoriteArticleParams struct {
	Slug   string
	UserID int64
}

func (q *Queries) FavoriteArticle(ctx context.Context, arg FavoriteArticleParams) (Article, error) {
	row := q.db.QueryRow(ctx, favoriteArticle, arg.Slug, arg.UserID)
	var i Article
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Title,
		&i.Description,
		&i.Body,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FavoritesCount,
		&i.AuthorID,
	)
	return i, err
}

const getArticle = `-- name: GetArticle :one

SELECT
    a.slug,
    a.title,
    a.description,
    a.body,
    a.created_at,
    a.updated_at,
    a.favorites_count,
    u.username AS author_username,
    u.bio AS author_bio,
    u.image AS author_image,
    ARRAY_AGG(t.tag) AS tag_list,
    (CASE WHEN EXISTS (SELECT 1 FROM favorites f WHERE f.article_id = a.id) THEN TRUE ELSE FALSE END) AS favorited
FROM
    articles a
        JOIN users u ON a.author_id = u.id
        LEFT JOIN article_tags at ON a.id = at.article_id
        LEFT JOIN tags t ON at.tag_id = t.id
WHERE
    a.slug = $1
GROUP BY
    a.id, u.id
`

type GetArticleRow struct {
	Slug           string
	Title          string
	Description    string
	Body           string
	CreatedAt      pgtype.Timestamp
	UpdatedAt      pgtype.Timestamp
	FavoritesCount int32
	AuthorUsername string
	AuthorBio      pgtype.Text
	AuthorImage    pgtype.Text
	TagList        interface{}
	Favorited      bool
}

// article.sql
func (q *Queries) GetArticle(ctx context.Context, slug string) (GetArticleRow, error) {
	row := q.db.QueryRow(ctx, getArticle, slug)
	var i GetArticleRow
	err := row.Scan(
		&i.Slug,
		&i.Title,
		&i.Description,
		&i.Body,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FavoritesCount,
		&i.AuthorUsername,
		&i.AuthorBio,
		&i.AuthorImage,
		&i.TagList,
		&i.Favorited,
	)
	return i, err
}

const unfavoriteArticle = `-- name: UnfavoriteArticle :one
WITH article_id_cte AS (
    SELECT a.id
    FROM articles a
    WHERE a.slug = $1
), delete_favorite AS (
    DELETE FROM favorites
        WHERE user_id = $2 AND article_id = (SELECT id FROM article_id_cte)
        RETURNING article_id
)
UPDATE articles
SET favorites_count = GREATEST(favorites_count - 1, 0)
WHERE id = (SELECT article_id FROM delete_favorite)
RETURNING id, slug, title, description, body, created_at, updated_at, favorites_count, author_id
`

type UnfavoriteArticleParams struct {
	Slug   string
	UserID int64
}

func (q *Queries) UnfavoriteArticle(ctx context.Context, arg UnfavoriteArticleParams) (Article, error) {
	row := q.db.QueryRow(ctx, unfavoriteArticle, arg.Slug, arg.UserID)
	var i Article
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Title,
		&i.Description,
		&i.Body,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FavoritesCount,
		&i.AuthorID,
	)
	return i, err
}

const updateArticle = `-- name: UpdateArticle :one
UPDATE articles
SET slug        = CASE WHEN $3::text IS NOT NULL AND $3::text <> '' THEN $3::text ELSE slug END,
    title       = CASE WHEN $4::text IS NOT NULL AND $4::text <> '' THEN $4::text ELSE title END,
    description = CASE WHEN $5::text IS NOT NULL AND $5::text <> '' THEN $5::text ELSE description END,
    body        = CASE WHEN $6::text IS NOT NULL AND $6::text <> '' THEN $6::text ELSE body END,
    updated_at  = CURRENT_TIMESTAMP
WHERE slug = $1 and author_id = $2
RETURNING id, slug, title, description, body, created_at, updated_at, favorites_count, author_id
`

type UpdateArticleParams struct {
	Slug        string
	AuthorID    pgtype.Int8
	Slug_2      string
	Title       string
	Description string
	Body        string
}

func (q *Queries) UpdateArticle(ctx context.Context, arg UpdateArticleParams) (Article, error) {
	row := q.db.QueryRow(ctx, updateArticle,
		arg.Slug,
		arg.AuthorID,
		arg.Slug_2,
		arg.Title,
		arg.Description,
		arg.Body,
	)
	var i Article
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Title,
		&i.Description,
		&i.Body,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FavoritesCount,
		&i.AuthorID,
	)
	return i, err
}
